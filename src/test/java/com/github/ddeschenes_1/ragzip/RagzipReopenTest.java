/**
 * Copyright (c) 2024 Danny Deschenes
 */

package com.github.ddeschenes_1.ragzip;

import static org.junit.jupiter.api.Assertions.*;

import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.StandardCharsets;
import java.nio.file.StandardOpenOption;
import java.util.Random;

import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

public class RagzipReopenTest {
	@ParameterizedTest
	@CsvSource({
		"2, 10, 5, 15000000, 100000",//last page ends at index1 of 3
		"2, 13, 12, 1000000, 100000",//last page ends at only index (level1)
		"2, 13, 12, 4000, 100000",//last page ends at 1st extension of 2, no index
		"1, 13, 12, 4000, 100000",//last page ends at only extension 
		"0, 13, 12, 4000, 100000",//last page ends at footer
		
		//resume after no data:
		"2, 10, 5, 0, 100000",
		"1, 10, 5, 0, 100000",
		"0, 10, 5, 0, 100000",
	})
	public void testResume(int nExtensions, int pse, int ise, int data1len, int data2len) throws IOException {
		
		System.out.println("\n\n----------------- ragzip channel reopen sanity -------------------");
		System.out.println("pse = "+pse+", ise = "+ise+", "+nExtensions+" extensions, "+data1len+" then "+data2len);
		
		int verbosity = 2;
		int cacheSizePerLevel = 0;
		
		Random r = new Random(20241208);
		byte[] data1 = new byte[data1len];
		r.nextBytes(data1);
		byte[] data2 = new byte[data2len];
		r.nextBytes(data2);
		
		//File f = new File("test.dat.reopen.rgz");
		File f = File.createTempFile("test.dat.resume_", ".rgz", new File("."));
		f.deleteOnExit();
		try (FileChannel fc = FileChannel.open(f.toPath(), StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.READ)) {
			fc.truncate(0);
			try (RagzipOutputStream zos = new RagzipOutputStream(fc, pse, ise)) {
				for(int i=1; i<= nExtensions; i++)
					zos.appendExtension(Extension.ofCustom(0x11 * i, 1001*i, "my extension "+1001*i));
				zos.write(data1);
			}
		}
		
		if(data1len==0) {
			int fl = 20 + (nExtensions*(10 +6 +8+1+4+17 +10)) + RagzipOutputStream.FOOTER_LENGTH64;
			assertEquals(fl, f.length(), "ragzip should be 1 emptypage (20) + extensions (n*56) + footer (64) ("+fl+"): "+f.length());
		}
		
		
		try (FileChannel fc = FileChannel.open(f.toPath(), StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.READ)) {
			//no truncate!!!!!
			
			try (RagzipOutputStream zos = new RagzipOutputStream(fc, pse+1, ise)) {
				fail("should have failed because of different tree spec");
			} catch(Exception e) {//
			}
			try (RagzipOutputStream zos = new RagzipOutputStream(fc, pse, ise+1)) {
				fail("should have failed because of different tree spec");
			} catch(Exception e) {//
			}
			
			try (RagzipOutputStream zos = new RagzipOutputStream(fc, pse, ise)) {
				assertEquals(nExtensions, zos.extensions.size(), "all "+nExtensions+" extensions were not recovered");
				zos.appendExtension(Extension.ofCustom(0x9, 99, "my last extension"));
				zos.write(data2);
			}
		}
		
		try (FileChannel fc = FileChannel.open(f.toPath(), StandardOpenOption.READ);
			RagzipFileChannel rag = new RagzipFileChannel(fc, verbosity, cacheSizePerLevel)) {
			assertEquals((nExtensions+1), rag.extensions.size(), "all "+(nExtensions+1)+" extensions were not recovered");
			for(int i=1; i<rag.extensions.size(); i++) {
				Extension x = rag.extensions.get(i-1);
				System.out.println(x);
				assertEquals((0x11*i)&0x7f, x.flags&0x7f);
				assertEquals(1001*i, x.id);
				assertArrayEquals(("my extension "+(1001*i)).getBytes(StandardCharsets.UTF_8), x.payload);
			}
			Extension x = rag.extensions.getLast();
			assertEquals(0x9, x.flags&0x7f);
			assertEquals(99, x.id);
			assertArrayEquals(("my last extension").getBytes(StandardCharsets.UTF_8), x.payload);
			
			rag.position(0);
			ByteBuffer bb = ByteBuffer.allocate(data1.length + data2.length);
			while(bb.hasRemaining() && rag.read(bb)>=0) {//
			}
			bb.flip();
			
			assertEquals(bb.capacity(), bb.limit());
			
			System.out.println("\nassert first part:");
			for (int i = 0; i < data1.length; i++) {
				int read = bb.get() & 0xff;
				int exp = data1[i] & 0xff;
				int _i = i;
				assertEquals(exp, read, () -> "1st part, error at logicalPos " + _i + ": expected:" + exp + ", read=" + read);
				if (i % 100_000 == 0)
					System.out.print('.');
			}
			
			System.out.println("\nassert second part:");
			for (int i = 0; i < data2.length; i++) {
				int read = bb.get() & 0xff;
				int exp = data2[i] & 0xff;
				int _i = i;
				assertEquals(exp, read, () -> "2nd part, error at logicalPos " + _i + ": expected:" + exp + ", read=" + read);
				if (i % 100_000 == 0)
					System.out.print('.');
			}
		}
		
		
		//!!!!!!!! OPEN IN TRUNCATE MODE !!!!!!!!
		try (FileChannel fc = FileChannel.open(f.toPath(), StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.READ)) {
			try (RagzipOutputStream zos = new RagzipOutputStream(fc, pse, ise, true)) {
				assertEquals(0, zos.extensions.size(), "extensions were not cleared");
			}
		}
		
		try (FileChannel fc = FileChannel.open(f.toPath(), StandardOpenOption.READ);
			RagzipFileChannel rag = new RagzipFileChannel(fc, verbosity, cacheSizePerLevel)) {
			assertEquals(0, rag.extensions.size(), "extensions were not cleared");
			assertEquals(0, rag.size(), "ragzip should be empty");
		}

	}
}
